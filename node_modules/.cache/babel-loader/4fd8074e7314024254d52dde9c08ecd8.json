{"ast":null,"code":"'use strict';\n\nconst kerberos = require('bindings')('kerberos');\n\nconst KerberosClient = kerberos.KerberosClient;\nconst KerberosServer = kerberos.KerberosServer;\n\nconst defineOperation = require('./util').defineOperation; // GSS Flags\n\n\nconst GSS_C_DELEG_FLAG = 1;\nconst GSS_C_MUTUAL_FLAG = 2;\nconst GSS_C_REPLAY_FLAG = 4;\nconst GSS_C_SEQUENCE_FLAG = 8;\nconst GSS_C_CONF_FLAG = 16;\nconst GSS_C_INTEG_FLAG = 32;\nconst GSS_C_ANON_FLAG = 64;\nconst GSS_C_PROT_READY_FLAG = 128;\nconst GSS_C_TRANS_FLAG = 256; // GSS_OID\n\nconst GSS_C_NO_OID = 0;\nconst GSS_MECH_OID_KRB5 = 9;\nconst GSS_MECH_OID_SPNEGO = 6;\n/**\n * @class KerberosClient\n *\n * @property {string} username The username used for authentication\n * @property {string} response The last response received during authentication steps\n * @property {string} responseConf Indicates whether confidentiality was applied or not (GSSAPI only)\n * @property {boolean} contextComplete Indicates that authentication has successfully completed or not\n */\n\n/**\n * Processes a single kerberos client-side step using the supplied server challenge.\n *\n * @kind function\n * @memberof KerberosClient\n * @param {string} challenge A string containing the base64-encoded server data (which may be empty for the first step)\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nKerberosClient.prototype.step = defineOperation(KerberosClient.prototype.step, [{\n  name: 'challenge',\n  type: 'string'\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * Perform the client side kerberos wrap step.\n *\n * @kind function\n * @memberof KerberosClient\n * @param {string} challenge The response returned after calling `unwrap`\n * @param {object} [options] Optional settings\n * @param {string} [options.user] The user to authorize\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nKerberosClient.prototype.wrap = defineOperation(KerberosClient.prototype.wrap, [{\n  name: 'challenge',\n  type: 'string'\n}, {\n  name: 'options',\n  type: 'object'\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * Perform the client side kerberos unwrap step\n *\n * @kind function\n * @memberof KerberosClient\n * @param {string} challenge A string containing the base64-encoded server data\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nKerberosClient.prototype.unwrap = defineOperation(KerberosClient.prototype.unwrap, [{\n  name: 'challenge',\n  type: 'string'\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * @class KerberosServer\n *\n * @property {string} username The username used for authentication\n * @property {string} response The last response received during authentication steps\n * @property {string} targetName The target used for authentication\n * @property {boolean} contextComplete Indicates that authentication has successfully completed or not\n */\n\n/**\n * Processes a single kerberos server-side step using the supplied client data.\n *\n * @kind function\n * @memberof KerberosServer\n * @param {string} challenge A string containing the base64-encoded client data\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nKerberosServer.prototype.step = defineOperation(KerberosServer.prototype.step, [{\n  name: 'challenge',\n  type: 'string'\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * This function provides a simple way to verify that a user name and password\n * match those normally used for Kerberos authentication.\n * It does this by checking that the supplied user name and password can be\n * used to get a ticket for the supplied service.\n * If the user name does not contain a realm, then the default realm supplied\n * is used.\n *\n * For this to work properly the Kerberos must be configured properly on this\n * machine.\n * That will likely mean ensuring that the edu.mit.Kerberos preference file\n * has the correct realms and KDCs listed.\n *\n * IMPORTANT: This method is vulnerable to KDC spoofing attacks and it should\n * only be used for testing. Do not use this in any production system - your\n * security could be compromised if you do.\n *\n * @kind function\n * @param {string} username The Kerberos user name. If no realm is supplied, then the `defaultRealm` will be used.\n * @param {string} password The password for the user.\n * @param {string} service The Kerberos service to check access for.\n * @param {string} [defaultRealm] The default realm to use if one is not supplied in the user argument.\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nconst checkPassword = defineOperation(kerberos.checkPassword, [{\n  name: 'username',\n  type: 'string'\n}, {\n  name: 'password',\n  type: 'string'\n}, {\n  name: 'service',\n  type: 'string'\n}, {\n  name: 'defaultRealm',\n  type: 'string',\n  required: false\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * This function returns the service principal for the server given a service type and hostname.\n *\n * Details are looked up via the `/etc/keytab` file.\n *\n * @kind function\n * @param {string} service The Kerberos service type for the server.\n * @param {string} hostname The hostname of the server.\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nconst principalDetails = defineOperation(kerberos.principalDetails, [{\n  name: 'service',\n  type: 'string'\n}, {\n  name: 'hostname',\n  type: 'string'\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * Initializes a context for client-side authentication with the given service principal.\n *\n * @kind function\n * @param {string} service A string containing the service principal in the form 'type@fqdn' (e.g. 'imap@mail.apple.com').\n * @param {object} [options] Optional settings\n * @param {string} [options.principal] Optional string containing the client principal in the form 'user@realm' (e.g. 'jdoe@example.com').\n * @param {number} [options.gssFlags] Optional integer used to set GSS flags. (e.g.  GSS_C_DELEG_FLAG|GSS_C_MUTUAL_FLAG|GSS_C_SEQUENCE_FLAG will allow for forwarding credentials to the remote host)\n * @param {number} [options.mechOID] Optional GSS mech OID. Defaults to None (GSS_C_NO_OID). Other possible values are `GSS_MECH_OID_KRB5`, `GSS_MECH_OID_SPNEGO`.\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nconst initializeClient = defineOperation(kerberos.initializeClient, [{\n  name: 'service',\n  type: 'string'\n}, {\n  name: 'options',\n  type: 'object',\n  default: {\n    mechOID: GSS_C_NO_OID\n  }\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\n/**\n * Initializes a context for server-side authentication with the given service principal.\n *\n * @kind function\n * @param {string} service A string containing the service principal in the form 'type@fqdn' (e.g. 'imap@mail.apple.com').\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\n\nconst initializeServer = defineOperation(kerberos.initializeServer, [{\n  name: 'service',\n  type: 'string'\n}, {\n  name: 'callback',\n  type: 'function',\n  required: false\n}]);\nmodule.exports = {\n  initializeClient,\n  initializeServer,\n  principalDetails,\n  checkPassword,\n  // gss flags\n  GSS_C_DELEG_FLAG,\n  GSS_C_MUTUAL_FLAG,\n  GSS_C_REPLAY_FLAG,\n  GSS_C_SEQUENCE_FLAG,\n  GSS_C_CONF_FLAG,\n  GSS_C_INTEG_FLAG,\n  GSS_C_ANON_FLAG,\n  GSS_C_PROT_READY_FLAG,\n  GSS_C_TRANS_FLAG,\n  GSS_C_NO_OID,\n  // mechanism OIDs\n  GSS_MECH_OID_KRB5,\n  GSS_MECH_OID_SPNEGO\n};","map":{"version":3,"sources":["C:/Users/Josh/Desktop/ld/LDREACT/node_modules/kerberos/lib/kerberos.js"],"names":["kerberos","require","KerberosClient","KerberosServer","defineOperation","GSS_C_DELEG_FLAG","GSS_C_MUTUAL_FLAG","GSS_C_REPLAY_FLAG","GSS_C_SEQUENCE_FLAG","GSS_C_CONF_FLAG","GSS_C_INTEG_FLAG","GSS_C_ANON_FLAG","GSS_C_PROT_READY_FLAG","GSS_C_TRANS_FLAG","GSS_C_NO_OID","GSS_MECH_OID_KRB5","GSS_MECH_OID_SPNEGO","prototype","step","name","type","required","wrap","unwrap","checkPassword","principalDetails","initializeClient","default","mechOID","initializeServer","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst kerberos = require('bindings')('kerberos');\nconst KerberosClient = kerberos.KerberosClient;\nconst KerberosServer = kerberos.KerberosServer;\nconst defineOperation = require('./util').defineOperation;\n\n// GSS Flags\nconst GSS_C_DELEG_FLAG = 1;\nconst GSS_C_MUTUAL_FLAG = 2;\nconst GSS_C_REPLAY_FLAG = 4;\nconst GSS_C_SEQUENCE_FLAG = 8;\nconst GSS_C_CONF_FLAG = 16;\nconst GSS_C_INTEG_FLAG = 32;\nconst GSS_C_ANON_FLAG = 64;\nconst GSS_C_PROT_READY_FLAG = 128;\nconst GSS_C_TRANS_FLAG = 256;\n\n// GSS_OID\nconst GSS_C_NO_OID = 0;\nconst GSS_MECH_OID_KRB5 = 9;\nconst GSS_MECH_OID_SPNEGO = 6;\n\n/**\n * @class KerberosClient\n *\n * @property {string} username The username used for authentication\n * @property {string} response The last response received during authentication steps\n * @property {string} responseConf Indicates whether confidentiality was applied or not (GSSAPI only)\n * @property {boolean} contextComplete Indicates that authentication has successfully completed or not\n */\n\n/**\n * Processes a single kerberos client-side step using the supplied server challenge.\n *\n * @kind function\n * @memberof KerberosClient\n * @param {string} challenge A string containing the base64-encoded server data (which may be empty for the first step)\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nKerberosClient.prototype.step = defineOperation(KerberosClient.prototype.step, [\n  { name: 'challenge', type: 'string' },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * Perform the client side kerberos wrap step.\n *\n * @kind function\n * @memberof KerberosClient\n * @param {string} challenge The response returned after calling `unwrap`\n * @param {object} [options] Optional settings\n * @param {string} [options.user] The user to authorize\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nKerberosClient.prototype.wrap = defineOperation(KerberosClient.prototype.wrap, [\n  { name: 'challenge', type: 'string' },\n  { name: 'options', type: 'object' },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * Perform the client side kerberos unwrap step\n *\n * @kind function\n * @memberof KerberosClient\n * @param {string} challenge A string containing the base64-encoded server data\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nKerberosClient.prototype.unwrap = defineOperation(KerberosClient.prototype.unwrap, [\n  { name: 'challenge', type: 'string' },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * @class KerberosServer\n *\n * @property {string} username The username used for authentication\n * @property {string} response The last response received during authentication steps\n * @property {string} targetName The target used for authentication\n * @property {boolean} contextComplete Indicates that authentication has successfully completed or not\n */\n\n/**\n * Processes a single kerberos server-side step using the supplied client data.\n *\n * @kind function\n * @memberof KerberosServer\n * @param {string} challenge A string containing the base64-encoded client data\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nKerberosServer.prototype.step = defineOperation(KerberosServer.prototype.step, [\n  { name: 'challenge', type: 'string' },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * This function provides a simple way to verify that a user name and password\n * match those normally used for Kerberos authentication.\n * It does this by checking that the supplied user name and password can be\n * used to get a ticket for the supplied service.\n * If the user name does not contain a realm, then the default realm supplied\n * is used.\n *\n * For this to work properly the Kerberos must be configured properly on this\n * machine.\n * That will likely mean ensuring that the edu.mit.Kerberos preference file\n * has the correct realms and KDCs listed.\n *\n * IMPORTANT: This method is vulnerable to KDC spoofing attacks and it should\n * only be used for testing. Do not use this in any production system - your\n * security could be compromised if you do.\n *\n * @kind function\n * @param {string} username The Kerberos user name. If no realm is supplied, then the `defaultRealm` will be used.\n * @param {string} password The password for the user.\n * @param {string} service The Kerberos service to check access for.\n * @param {string} [defaultRealm] The default realm to use if one is not supplied in the user argument.\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nconst checkPassword = defineOperation(kerberos.checkPassword, [\n  { name: 'username', type: 'string' },\n  { name: 'password', type: 'string' },\n  { name: 'service', type: 'string' },\n  { name: 'defaultRealm', type: 'string', required: false },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * This function returns the service principal for the server given a service type and hostname.\n *\n * Details are looked up via the `/etc/keytab` file.\n *\n * @kind function\n * @param {string} service The Kerberos service type for the server.\n * @param {string} hostname The hostname of the server.\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nconst principalDetails = defineOperation(kerberos.principalDetails, [\n  { name: 'service', type: 'string' },\n  { name: 'hostname', type: 'string' },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * Initializes a context for client-side authentication with the given service principal.\n *\n * @kind function\n * @param {string} service A string containing the service principal in the form 'type@fqdn' (e.g. 'imap@mail.apple.com').\n * @param {object} [options] Optional settings\n * @param {string} [options.principal] Optional string containing the client principal in the form 'user@realm' (e.g. 'jdoe@example.com').\n * @param {number} [options.gssFlags] Optional integer used to set GSS flags. (e.g.  GSS_C_DELEG_FLAG|GSS_C_MUTUAL_FLAG|GSS_C_SEQUENCE_FLAG will allow for forwarding credentials to the remote host)\n * @param {number} [options.mechOID] Optional GSS mech OID. Defaults to None (GSS_C_NO_OID). Other possible values are `GSS_MECH_OID_KRB5`, `GSS_MECH_OID_SPNEGO`.\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nconst initializeClient = defineOperation(kerberos.initializeClient, [\n  { name: 'service', type: 'string' },\n  { name: 'options', type: 'object', default: { mechOID: GSS_C_NO_OID } },\n  { name: 'callback', type: 'function', required: false }\n]);\n\n/**\n * Initializes a context for server-side authentication with the given service principal.\n *\n * @kind function\n * @param {string} service A string containing the service principal in the form 'type@fqdn' (e.g. 'imap@mail.apple.com').\n * @param {function} [callback]\n * @return {Promise} returns Promise if no callback passed\n */\nconst initializeServer = defineOperation(kerberos.initializeServer, [\n  { name: 'service', type: 'string' },\n  { name: 'callback', type: 'function', required: false }\n]);\n\nmodule.exports = {\n  initializeClient,\n  initializeServer,\n  principalDetails,\n  checkPassword,\n\n  // gss flags\n  GSS_C_DELEG_FLAG,\n  GSS_C_MUTUAL_FLAG,\n  GSS_C_REPLAY_FLAG,\n  GSS_C_SEQUENCE_FLAG,\n  GSS_C_CONF_FLAG,\n  GSS_C_INTEG_FLAG,\n  GSS_C_ANON_FLAG,\n  GSS_C_PROT_READY_FLAG,\n  GSS_C_TRANS_FLAG,\n  GSS_C_NO_OID,\n\n  // mechanism OIDs\n  GSS_MECH_OID_KRB5,\n  GSS_MECH_OID_SPNEGO\n};\n"]},"metadata":{},"sourceType":"script"}