{"ast":null,"code":"'use strict';\n\nfunction validateParameter(parameter, specs, specIndex) {\n  const spec = specs[specIndex];\n\n  if (parameter == null && spec.required === false) {\n    return;\n  }\n\n  if (parameter == null) {\n    throw new TypeError(`Required parameter \\`${spec.name}\\` missing`);\n  }\n\n  const paramType = typeof parameter;\n\n  if (spec.type && paramType !== spec.type) {\n    if (spec.required === false) {\n      if (specs.slice(specIndex).some(def => def.type === paramType)) {\n        return false;\n      }\n    }\n\n    throw new TypeError(`Invalid type for parameter \\`${spec.name}\\`, expected \\`${spec.type}\\` but found \\`${typeof parameter}\\``);\n  }\n\n  return true;\n}\n/**\n * Monkey-patches an existing method to support parameter validation, as well\n * as adding support for returning Promises if callbacks are not provided.\n *\n * @private\n * @param {function} fn the function to override\n * @param {Array<Object>} paramDefs the definitions of each parameter to the function\n */\n\n\nfunction defineOperation(fn, paramDefs) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    const params = [];\n\n    for (let i = 0, argIdx = 0; i < paramDefs.length; ++i, ++argIdx) {\n      const def = paramDefs[i];\n      let arg = args[argIdx];\n      if (def.hasOwnProperty('default') && arg == null) arg = def.default;\n\n      if (def.type === 'object' && def.default != null) {\n        arg = Object.assign({}, def.default, arg);\n      } // special case to allow `options` to be optional\n\n\n      if (def.name === 'options' && (typeof arg === 'function' || arg == null)) {\n        arg = {};\n      }\n\n      if (validateParameter(arg, paramDefs, i)) {\n        params.push(arg);\n      } else {\n        argIdx--;\n      }\n    }\n\n    const callback = arguments[arguments.length - 1];\n\n    if (typeof callback !== 'function') {\n      return new Promise((resolve, reject) => {\n        params.push((err, response) => {\n          if (err) return reject(err);\n          resolve(response);\n        });\n        fn.apply(this, params);\n      });\n    }\n\n    fn.apply(this, params);\n  };\n}\n\nmodule.exports = {\n  defineOperation,\n  validateParameter\n};","map":{"version":3,"sources":["C:/Users/Josh/Desktop/ld/LDREACT/node_modules/kerberos/lib/util.js"],"names":["validateParameter","parameter","specs","specIndex","spec","required","TypeError","name","paramType","type","slice","some","def","defineOperation","fn","paramDefs","args","Array","prototype","call","arguments","params","i","argIdx","length","arg","hasOwnProperty","default","Object","assign","push","callback","Promise","resolve","reject","err","response","apply","module","exports"],"mappings":"AAAA;;AAEA,SAASA,iBAAT,CAA2BC,SAA3B,EAAsCC,KAAtC,EAA6CC,SAA7C,EAAwD;AACtD,QAAMC,IAAI,GAAGF,KAAK,CAACC,SAAD,CAAlB;;AACA,MAAIF,SAAS,IAAI,IAAb,IAAqBG,IAAI,CAACC,QAAL,KAAkB,KAA3C,EAAkD;AAChD;AACD;;AAED,MAAIJ,SAAS,IAAI,IAAjB,EAAuB;AACrB,UAAM,IAAIK,SAAJ,CAAe,wBAAuBF,IAAI,CAACG,IAAK,YAAhD,CAAN;AACD;;AAED,QAAMC,SAAS,GAAG,OAAOP,SAAzB;;AACA,MAAIG,IAAI,CAACK,IAAL,IAAaD,SAAS,KAAKJ,IAAI,CAACK,IAApC,EAA0C;AACxC,QAAIL,IAAI,CAACC,QAAL,KAAkB,KAAtB,EAA6B;AAC3B,UAAIH,KAAK,CAACQ,KAAN,CAAYP,SAAZ,EAAuBQ,IAAvB,CAA4BC,GAAG,IAAIA,GAAG,CAACH,IAAJ,KAAaD,SAAhD,CAAJ,EAAgE;AAC9D,eAAO,KAAP;AACD;AACF;;AAED,UAAM,IAAIF,SAAJ,CACH,gCAA+BF,IAAI,CAACG,IAAK,kBACxCH,IAAI,CAACK,IACN,kBAAiB,OAAOR,SAAU,IAH/B,CAAN;AAKD;;AAED,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASY,eAAT,CAAyBC,EAAzB,EAA6BC,SAA7B,EAAwC;AACtC,SAAO,YAAW;AAChB,UAAMC,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBR,KAAhB,CAAsBS,IAAtB,CAA2BC,SAA3B,CAAb;AACA,UAAMC,MAAM,GAAG,EAAf;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,MAAM,GAAG,CAAzB,EAA4BD,CAAC,GAAGP,SAAS,CAACS,MAA1C,EAAkD,EAAEF,CAAF,EAAK,EAAEC,MAAzD,EAAiE;AAC/D,YAAMX,GAAG,GAAGG,SAAS,CAACO,CAAD,CAArB;AACA,UAAIG,GAAG,GAAGT,IAAI,CAACO,MAAD,CAAd;AAEA,UAAIX,GAAG,CAACc,cAAJ,CAAmB,SAAnB,KAAiCD,GAAG,IAAI,IAA5C,EAAkDA,GAAG,GAAGb,GAAG,CAACe,OAAV;;AAClD,UAAIf,GAAG,CAACH,IAAJ,KAAa,QAAb,IAAyBG,GAAG,CAACe,OAAJ,IAAe,IAA5C,EAAkD;AAChDF,QAAAA,GAAG,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBjB,GAAG,CAACe,OAAtB,EAA+BF,GAA/B,CAAN;AACD,OAP8D,CAS/D;;;AACA,UAAIb,GAAG,CAACL,IAAJ,KAAa,SAAb,KAA2B,OAAOkB,GAAP,KAAe,UAAf,IAA6BA,GAAG,IAAI,IAA/D,CAAJ,EAA0E;AACxEA,QAAAA,GAAG,GAAG,EAAN;AACD;;AAED,UAAIzB,iBAAiB,CAACyB,GAAD,EAAMV,SAAN,EAAiBO,CAAjB,CAArB,EAA0C;AACxCD,QAAAA,MAAM,CAACS,IAAP,CAAYL,GAAZ;AACD,OAFD,MAEO;AACLF,QAAAA,MAAM;AACP;AACF;;AAED,UAAMQ,QAAQ,GAAGX,SAAS,CAACA,SAAS,CAACI,MAAV,GAAmB,CAApB,CAA1B;;AACA,QAAI,OAAOO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,aAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCb,QAAAA,MAAM,CAACS,IAAP,CAAY,CAACK,GAAD,EAAMC,QAAN,KAAmB;AAC7B,cAAID,GAAJ,EAAS,OAAOD,MAAM,CAACC,GAAD,CAAb;AACTF,UAAAA,OAAO,CAACG,QAAD,CAAP;AACD,SAHD;AAKAtB,QAAAA,EAAE,CAACuB,KAAH,CAAS,IAAT,EAAehB,MAAf;AACD,OAPM,CAAP;AAQD;;AAEDP,IAAAA,EAAE,CAACuB,KAAH,CAAS,IAAT,EAAehB,MAAf;AACD,GArCD;AAsCD;;AAEDiB,MAAM,CAACC,OAAP,GAAiB;AAAE1B,EAAAA,eAAF;AAAmBb,EAAAA;AAAnB,CAAjB","sourcesContent":["'use strict';\n\nfunction validateParameter(parameter, specs, specIndex) {\n  const spec = specs[specIndex];\n  if (parameter == null && spec.required === false) {\n    return;\n  }\n\n  if (parameter == null) {\n    throw new TypeError(`Required parameter \\`${spec.name}\\` missing`);\n  }\n\n  const paramType = typeof parameter;\n  if (spec.type && paramType !== spec.type) {\n    if (spec.required === false) {\n      if (specs.slice(specIndex).some(def => def.type === paramType)) {\n        return false;\n      }\n    }\n\n    throw new TypeError(\n      `Invalid type for parameter \\`${spec.name}\\`, expected \\`${\n        spec.type\n      }\\` but found \\`${typeof parameter}\\``\n    );\n  }\n\n  return true;\n}\n\n/**\n * Monkey-patches an existing method to support parameter validation, as well\n * as adding support for returning Promises if callbacks are not provided.\n *\n * @private\n * @param {function} fn the function to override\n * @param {Array<Object>} paramDefs the definitions of each parameter to the function\n */\nfunction defineOperation(fn, paramDefs) {\n  return function() {\n    const args = Array.prototype.slice.call(arguments);\n    const params = [];\n    for (let i = 0, argIdx = 0; i < paramDefs.length; ++i, ++argIdx) {\n      const def = paramDefs[i];\n      let arg = args[argIdx];\n\n      if (def.hasOwnProperty('default') && arg == null) arg = def.default;\n      if (def.type === 'object' && def.default != null) {\n        arg = Object.assign({}, def.default, arg);\n      }\n\n      // special case to allow `options` to be optional\n      if (def.name === 'options' && (typeof arg === 'function' || arg == null)) {\n        arg = {};\n      }\n\n      if (validateParameter(arg, paramDefs, i)) {\n        params.push(arg);\n      } else {\n        argIdx--;\n      }\n    }\n\n    const callback = arguments[arguments.length - 1];\n    if (typeof callback !== 'function') {\n      return new Promise((resolve, reject) => {\n        params.push((err, response) => {\n          if (err) return reject(err);\n          resolve(response);\n        });\n\n        fn.apply(this, params);\n      });\n    }\n\n    fn.apply(this, params);\n  };\n}\n\nmodule.exports = { defineOperation, validateParameter };\n"]},"metadata":{},"sourceType":"script"}